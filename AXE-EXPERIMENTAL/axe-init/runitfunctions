#!/bin/bash
# axe init functions
#

#############################################################
#                    Common preperations                    #
#############################################################
# sanitize PATH (will be overridden later when /etc/profile is sourced, but is useful for UDev)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# clear the TZ envvar, so daemons always respect /etc/localtime
unset TZ

# These can be overridden/reused for customizations like shutdown/loop-fsck.
NETFS="nfs,nfs4,smbfs,cifs,codafs,ncpfs,shfs,fuse,fuseblk,glusterfs,davfs,fuse.glusterfs"
NO_NETFS="no${NETFS//,/,no}"
APIFS="devpts,devtmpfs,proc,sysfs,tmpfs"
NO_APIFS="no${APIFS//,/,no}"

RANDOM_SEED=/var/lib/misc/random-seed

# prefixes
PREFIX_HL=" > "
PREFIX_MSG=" * "
PREFIX_STD="   >> "

# set colors
if [ "${USE_COLOR}" = "yes" ] && [ -t 0 ];then
    C_BLACK='\e[1;30m'
    C_RED='\e[1;31m'
    C_GREEN='\e[1;32m'
    C_YELLOW='\e[1;33m'
    C_BLUE='\e[1;34m'
    C_PURPLE='\e[1;35m'
    C_CYAN='\e[1;36m'
    C_WHITE='\e[1;37m'
    C_CLEAR='\e[m'
fi


#############################################################
#                          Messages                         #
#############################################################

msg_headline() {
	printf "\n${C_BLUE}${PREFIX_HL}${C_WHITE}${1}${C_CLEAR}\n\n"
}

msg_busy() {
	printf "${C_CYAN}${PREFIX_MSG}${C_WHITE}${1}${C_CLEAR}"
}

msg_ok() {
    printf "\r${C_BLUE}${PREFIX_MSG}${C_WHITE}${1}${C_CLEAR}\n"
}

msg_fail() {
    printf "\r${C_RED}${PREFIX_MSG}${C_WHITE}${1}${C_CLEAR}\n"
}

msg_die() {
	msg_fail "${1}"
	exit "${2:-1}"
}

msg_status() {
    if [ "${?}" = "${1:-0}" ];then
        msg_ok
    else
        msg_fail
    fi
}


#############################################################
#                      Common routines                      #
#############################################################
# execute and output stderr without cluttering stdout
# usage: exec_cmd "<message>" <command>
exec_cmd() {
    local msg="${1}"
    local cmd="${@:2}"
    local std
    local line
    
    msg_busy "${msg}"
    std=$(${cmd} 2>&1)
    msg_status
    
    if [ -n "${std}" ];then
        printf "${std}" | while IFS= read -r line;do
            printf "${C_YELLOW}${PREFIX_STD}${C_WHITE}${line}${C_CLEAR}\n"
        done
    fi
}

# check if current user is root
# usage: chk_root || <error handler>
chk_root() {
    if [ "$(id -u)" = "0" ];then
        return 0
    else
        return 1
    fi
}

# check if string is present in array
# usage : chk_in_array <needle> <haystack>
chk_in_array() {
	local needle=$1; shift
	local item
	for item; do
		if [ "${item}" = "${needle}" ];then
            return 0
        fi
	done
	return 1
}

# return PID of process
# usage: pid_get <process name>
pid_get() {
	pidof -o %PPID "${1}" || return 1
}

# check if PID is still the active PID for command
# usage: pid_check <pid> <command> || <error handler>
pid_check() {
	if [ -f "${1}" ]; then
		local fpid ppid
		read -r fpid <"$1"
		ppid=$(get_pid "$2")
		[[ $fpid = "${ppid}" ]] && return 0
	fi
	return 1
}

# PIDs to be omitted by killall5
# usage: pid_add_omit <pid>
declare -a omit_pids
pid_add_omit() {
	omit_pids+=( ${@} )
}


#############################################################
#                  System initialization                    #
#############################################################
# stop bootlogd daemon
int_bootlogd_stop() {
	if [ -f "/run/bootlogd.pid" ];then
        touch /var/log/boot
        kill $(< /run/bootlogd.pid)
        rm /run/bootlogd.pid
    fi
}

# start and trigger UDev daemon
int_udev_start() {
	udevd --daemon
	udevadm trigger --action=add --type=subsystems
    udevadm trigger --action=add --type=devices
}

# setup system hardware clock
int_hwclock_set() {
    if [ -n "${TIME_ZONE}" ];then
        env TZ="${TIME_ZONE}" hwclock --systz ${@}
    else
        hwclock ${@}
    fi
}

# check local filesystems
int_fsck_all() {
    local fsck_options

	if [[ -f /forcefsck ]] || chk_in_array forcefsck $(< /proc/cmdline); then
		fsck_options="-f"
	elif [[ -f /fastboot ]] || chk_in_array fastboot $(< /proc/cmdline); then
		return 0
	elif [[ -e /run/initramfs/root-fsck ]]; then
		fsck_options="-M"
	fi

	fsck -T -A -P -a -t "${NO_NETFS}" ${fsck_options}

    # Automatic reboot after fsck (if needed)
	# Ignore conditions 'FS errors corrected' and 'Cancelled by the user'
	if [ "${?}" = "2" ]; then
		printf "\n\n${C_RED}********************** ${C_YELLOW}REBOOT REQUIRED${C_RED} *********************${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}                                                          ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE} The system will be rebooted automatically in 15 seconds. ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}                                                          ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}************************************************************${C_CLEAR}\n\n"
		sleep 15
        msg_headline "Automatic reboot in progress..."
        umount --all
        mount --options remount,ro /
        reboot -f
        exit 0
	elif [ "${?}" = "4" ] || [ "${?}" = "8" ]; then
		printf "\n\n${C_RED}*****************  ${C_YELLOW}FILESYSTEM CHECK FAILED${C_RED}  ****************${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}                                                          ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}  Please repair manually and reboot. Note that the root   ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}  file system is currently mounted read-only. To remount  ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}  it read-write type: ${C_RED}mount -o remount,rw /${C_WHITE}               ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}  When you exit the maintenance shell, the system will    ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}  reboot automatically.                                   ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}*${C_WHITE}                                                          ${C_RED}*${C_CLEAR}\n"
		printf "${C_RED}************************************************************${C_CLEAR}\n\n"
		sulogin -p
	fi
}

# removing leftover files
int_leftovers_remove() {
	/etc/runit/tmpfiles --create --remove
}

# setup system time zone
int_timezone_set() {
	if [ "$(readlink /etc/localtime)" != "/usr/share/zoneinfo/${1}" ];then
        ln --symbolic --force "/usr/share/zoneinfo/${1}" "/etc/localtime"
	fi
}

# save boot log to file for reference
int_dmesg_save() {
    if [ "$(</proc/sys/kernel/dmesg_restrict)" = "1" ]; then
        install -Tm 0600 <( dmesg ) /var/log/dmesg.log
    else
        install -Tm 0644 <( dmesg ) /var/log/dmesg.log
    fi
}

# mount all local filesystems
int_mount_all() {
	mount --all --types "nosysfs,${NO_NETFS}"
}

# save entrophy file
int_urandom_save() {
    local pool_file="/proc/sys/kernel/random/poolsize"
    local pool_size="512"
    
    install -TDm 0600 /dev/null "${RANDOM_SEED}"

	if [ -r "${pool_file}" ]; then
		pool_size=$(< "${pool_file}")
	fi
    
	dd if=/dev/urandom of="${RANDOM_SEED}" count=1 bs="${pool_size}"
}

# unmount all filesystems, ${1} restricts to fstype
int_umount_all() {
    local fstype

	findmnt -mrunRo TARGET,FSTYPE,OPTIONS / | {
		while read -r target fstype options; do
			# match only targeted fstypes
			if [ "${1}" != "$fstype" ]; then
				continue
			fi

			# do not unmount API filesystems
			if [[ $target = /@(proc|sys|run|dev|dev/pts) ]]; then
				continue
			fi

			# avoid networked devices
			IFS=, read -ra opts <<< "$options"
			if chk_in_array _netdev "${opts[@]}"; then
				continue
			fi

			mounts=("$target" "${mounts[@]}")
		done

		if (( ${#mounts[*]} )); then
			umount --read-only "${mounts[@]}"
		fi
	}

}

# $1 - signal
# $2 - iterations
int_killall_wait() {
	# Send SIGTERM/SIGKILL all processes and wait until killall5
	# reports all done or timeout.
	# Unfortunately killall5 does not support the 0 signal, so just
	# use SIGCONT for checking (which should be ignored).

	local i

	killall5 -${1} ${omit_pids[@]/#/-o }

	for (( i=0; i<${2}; i++ )); do

		sleep .25 # 1/4 second

		# sending SIGCONT to processes to check if they are there
		killall5 -18 ${omit_pids[@]/#/-o }

		if (( $? == 2 )); then
			return 0
		fi
	done

	return 1
}